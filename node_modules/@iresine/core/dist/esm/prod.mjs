import e from"@iresine/object-path";import{isObject as t,setUniq as s,setAdd as r,isEmptyObject as o}from"@iresine/helpers";class n{constructor(e){this.parents=new Set,this.refs=new Map,this.prepared=null,this.listeners=new Set,this.storeId=e}get children(){return new Set(this.refs.values())}}class i{constructor({getId:e,hooks:t}={}){this._hooks={},this.models=new Map,this.updated=new Set,t&&(t.join&&(this._hooks.join=t.join),t.parse&&(this._hooks.parse=t.parse)),e&&(this._getId=e)}_getId(e){return e&&e.id&&e.type?`${e.type}:${e.id}`:null}_isTemplate(e){return null!==this._getId(e)}_getStructureType(e){return Array.isArray(e)?"array":this._isTemplate(e)?"template":t(e)?"object":"unknown"}parse(e){if("unknown"===this._getStructureType(e))return null;const t=this._parse(e),s=this._reconciliation(this.updated.values());return this._notify(new Set([...this.updated,...s])),this.updated.clear(),t}get(e){const t=this.models.get(e);return t.prepared||this.join(e),t.prepared}join(t){const s=this.models.get(t),r=e.joinTemplate(s.template);s.prepared=r;for(let[t,o]of s.refs){const s=this.get(this.models.get(o).storeId);e.set(r,t,s)}return this._hooks.join&&this._hooks.join(r),r}subscribe(e,t){for(const s of e)this.models.get(s).listeners.add(t)}unsubscribe(e,t){for(const s of e)this.models.get(s).listeners.delete(t)}joinRefs(t,s){if(1===s.size&&0===[...s.keys()][0].length)return this.get([...s.values()][0]);const r=e.joinTemplate(t);for(const[t,o]of s.entries())e.set(r,t,this.get(o));return r}_notify(e){const t=new Set;for(const s of e){const e=this.models.get(s);for(const s of e.listeners)t.add(s)}for(const s of t)s([...e])}_reconciliation(e){const t=new Set;for(const s of e){const e=this.models.get(s);for(const s of e.parents)t.add(s)}for(const e of t){if(this.updated.has(e))continue;const s=this.models.get(e);for(const e of s.parents.values())t.add(e);s.prepared=null}for(const e of t)this.updated.has(e)||this.join(e);return t}_insert(e,t,o){if(this.updated.has(e))return;let i=this.models.get(e),a=null;i?a=i.children:(this.models.set(e,new n(e)),i=this.models.get(e)),this.updated.add(e),i.prepared=t;const{refs:h,template:l}=this._parse(t,{parentModel:i,omitNextTemplate:!0});if(i.refs=h,i.template=l,a){const e=s(a,i.children);for(const t of e)this.models.get(t).parents.delete(i.storeId)}o&&r(i.parents,o)}_parse(e,{parentModel:t,omitNextTemplate:s=!1}={}){const r=[[[],e]],n=[[[],Array.isArray(e)?[]:{}]],i=new Map;for(let e=0;e<r.length;e++){1===e&&(s=!1);const a=r[e],h=a[0],l=a[1],p=this._getStructureType(l);if("unknown"!==p)if("template"!==p||!1!==s)if("object"!==p&&"template"!==p)if("array"!==p);else{0===l.length&&n.push([h,[]]);for(let e=0;e<l.length;e++){let t=e.toString();Array.isArray(l[e])&&(t=`[]${t}`),r.push([[...h,t],l[t]])}}else{for(let e in l){let t=e;Array.isArray(l[e])&&(t=`[]${e}`),r.push([[...h,t],l[e]])}o(l)&&n.push([h,{}])}else{this._hooks.parse&&this._hooks.parse(l);const e=this._getId(l);i.set(h,e),t?this._insert(e,l,[t.storeId]):this._insert(e,l,[])}else n.push([h,l])}return{refs:i,template:n}}}export default i;export{i as Iresine};
